import matplotlib.pyplot as plt
import numpy as np
import control
T = 0.1
n = 3
alpha = 1000
data = np.array([[0.00, 0.00],
[0.00, 0.03],
[0.01, 4.83],
[0.07, 5.00],
[0.17, 5.00],
[0.30, 5.00],
[0.47, 5.00],
[0.66, 5.00],
[0.87, 5.00],
[1.10, 5.00],
[1.34, 5.00],
[1.59, 5.00],
[1.83, 5.00],
[2.08, 5.00],
[2.32, 5.00],
[2.55, 5.00],
[2.77, 5.00],
[2.98, 5.00],
[3.17, 5.00],
[3.35, 5.00],
[3.51, 5.00],
[3.65, 5.00],
[3.77, 5.00],
[3.88, 5.00],
[3.96, 5.00],
[4.04, 5.00],
[4.09, 5.00],
[4.13, 5.00],
[4.14, 5.00],
[4.15, 5.00],
[4.15, 5.00],
[4.13, 5.00],
[4.11, 5.00],
[4.07, 5.00],
[4.03, 5.00],
[3.98, 5.00],
[3.93, 5.00],
[3.88, 5.00],
[3.81, 5.00],
[3.75, 5.00],
[3.70, 5.00],
[3.64, 5.00],
[3.58, 5.00],
[3.52, 5.00],
[3.47, 5.00],
[3.42, 5.00],
[3.37, 5.00],
[3.33, 5.00],
[3.29, 5.00],
[3.26, 5.00],
[3.23, 5.00],
[3.20, 4.96],
[3.17, 2.59],
[3.13, 2.49],
[3.06, 2.51],
[2.99, 2.51],
[2.90, 2.49],
[2.80, 2.51],
[2.70, 2.50],
[2.59, 2.50],
[2.48, 2.52],
[2.36, 2.51],
[2.25, 2.49],
[2.14, 2.52],
[2.03, 2.50],
[1.93, 2.49],
[1.84, 2.52],
[1.75, 2.50],
[1.67, 2.49],
[1.59, 2.52],
[1.53, 2.50],
[1.47, 2.49],
[1.42, 2.52],
[1.38, 2.50],
[1.35, 2.49],
[1.32, 2.52],
[1.30, 2.50],
[1.30, 2.50],
[1.30, 2.52],
[1.30, 2.49],
[1.30, 2.50],
[1.31, 2.52]
])

t = np.arange(0, len(data) * T, T)
u = np.array(data[:, 1])
y = np.array(data[:, 1])
plt.plot(t, y)
l = len(y) - n + 1
m = 2*n
Theta = np.zeros(shape=(m,1))
L = np.zeros(shape=(m,1))
ThetaT = Theta.transpose()
P = alpha*np.identity(m)
Error = np.zeros(l)
#F = np.zeros(2*n)
for i in range(l):
    print(i)
    F = np.array([-y[i+2], -y[i+1], -y[i], u[i+2], u[i+1], u[i]])
    Ft = F.transpose()
    Error[i] = y[i+1] - F.dot(Theta)
    L1= np.array([P.dot(F)/(1 + Ft.dot(P.dot(F)))])
    L = L1.transpose()
    ThetaT = ThetaT + Error[i]*L[:,0]
    P = np.identity(m) - L.dot(np.array([F.dot(P)]))
    Theta = ThetaT[0,:]
print(Theta)

plt.plot(t, y)
# Construcción de la función de transferencia
num = [Theta[3], Theta[4], Theta[5]]
den = [1, Theta[0], Theta[1], Theta[2]]
Hz = control.tf(num, den, T)
(Y, t1) = control.step_response(Hz, t)
plt.step(Y, t1)
plt.show()
print(Hz)